Role: Backend Engineer

Core Skills:

- Java or Python
  - Java
    - JVM architecture (Heap, Stack, Metaspace)
    - Garbage Collection (G1, ZGC, CMS)
    - Multithreading and concurrency
    - ExecutorService, Fork/Join framework
    - Synchronization, Locks, Atomic variables
    - Collections internals (HashMap, ConcurrentHashMap)
    - Exception handling best practices
    - Streams, Lambdas, Functional programming
    - Spring Boot fundamentals
    - Dependency Injection lifecycle
    - Transaction management
    - REST controllers and services
  - Python
    - Python memory management and garbage collection
    - Global Interpreter Lock (GIL)
    - Multithreading vs multiprocessing
    - Async programming (asyncio)
    - FastAPI / Flask backend development
    - Decorators and context managers
    - Type hints and data classes
    - Performance profiling and optimization
    - Caching using Redis or in-memory caches

- Data Structures and Algorithms
  - Arrays and Strings (sliding window, prefix sum)
  - Linked Lists (cycle detection, reversal)
  - Stacks and Queues
  - Trees (Binary Tree, BST, Trie)
  - Heaps and Priority Queues
  - Graphs (BFS, DFS, Topological sort)
  - Sorting and Searching algorithms
  - Greedy algorithms
  - Dynamic Programming
  - Bit manipulation
  - Time and Space Complexity analysis
  - Backend use cases
    - Rate limiting algorithms
    - Caching eviction strategies (LRU, LFU)
    - Consistent hashing
    - Load balancing logic

- SQL and NoSQL Databases
  - SQL
    - MySQL / PostgreSQL fundamentals
    - ACID properties
    - Indexing (B-Tree, Composite indexes)
    - Query optimization and execution plans
    - Joins and subqueries
    - Transactions and isolation levels
    - Deadlocks and MVCC
    - Normalization and denormalization
    - Replication and sharding
    - Backup and recovery
  - NoSQL
    - Key-Value databases (Redis)
    - Document databases (MongoDB)
    - Column-family databases (Cassandra)
    - CAP theorem
    - Eventual consistency
    - Data modeling for NoSQL
    - Indexing strategies
    - TTL and caching mechanisms

- REST API Development
  - REST principles and constraints
  - Resource-based API design
  - HTTP methods and status codes
  - Idempotency
  - Pagination, filtering, sorting
  - API versioning strategies
  - Error handling standards
  - API documentation (Swagger / OpenAPI)
  - Authentication (JWT, OAuth 2.0)
  - Authorization (RBAC)
  - Input validation and security
  - Rate limiting and throttling
  - Caching strategies
  - Performance optimization

- Git Version Control
  - Git basics (clone, commit, push, pull)
  - Branching strategies
  - Merge vs rebase
  - Resolving merge conflicts
  - Cherry-pick and tagging
  - Code review workflows
  - CI/CD integration
  - Branch protection and release management

Good to Have:

- Docker
  - Docker architecture
  - Dockerfile best practices
  - Multi-stage builds
  - Docker Compose
  - Container networking
  - Volume management
  - Optimizing image size
  - Running Java and Python services in containers

- System Design
  - Scalability and availability
  - Latency vs throughput
  - Load balancers
  - Caching layers
  - Message queues
  - Database scaling
  - Microservices vs Monolith
  - Event-driven architecture
  - Design patterns (CQRS, Saga)
  - Common system design problems

- Cloud Fundamentals
  - IaaS, PaaS, SaaS
  - Virtual machines and containers
  - Regions and availability zones
  - Compute services
  - Storage services
  - Managed databases
  - Networking basics
  - IAM and security
  - CI/CD pipelines
  - Monitoring and logging
  - Auto-scaling concepts
Typical Projects:

- Problem-Solving Applications
  - Algorithm-based applications
  - Competitive programming style tools
  - Coding practice platforms
  - Data structure visualization tools
  - Search and optimization engines
  - Path-finding and graph-based solutions
  - Scheduling and resource allocation systems
  - Performance-focused computation modules
  - Memory-efficient implementations
  - Modular and reusable code design

- Backend Services
  - RESTful backend services
  - CRUD-based service development
  - Authentication and authorization modules
  - User management systems
  - API integration services
  - Data processing services
  - Microservice-style backend components
  - Logging and monitoring services
  - Error handling and validation layers
  - Scalable service architecture


Good to Have:

- System Design
  - Basic scalability concepts
  - High-level architecture design
  - Component interaction diagrams
  - Load balancing fundamentals
  - Caching strategies
  - Stateless vs stateful services
  - Monolith vs microservices
  - API design considerations
  - Reliability and fault tolerance
  - Performance bottleneck identification

- Databases
  - Relational database fundamentals
  - Basic SQL queries and joins
  - Indexing basics
  - Schema design
  - Normalization concepts
  - NoSQL database basics
  - Key-value and document databases
  - Data consistency concepts
  - Connection handling
  - Query optimization basics

- Testing
  - Unit testing fundamentals
  - Writing testable code
  - Test case design
  - Edge case handling
  - Mocking and stubbing
  - Integration testing basics
  - Regression testing
  - Code coverage understanding
  - Debugging techniques
  - Automated testing tools


Interview Focus:

- Data Structures and Algorithms
  - Arrays, Strings, Linked Lists
  - Stacks and Queues
  - Trees and Binary Search Trees
  - Heaps and Priority Queues
  - Hashing techniques
  - Graph traversal algorithms
  - Sorting and searching algorithms
  - Recursion and backtracking
  - Dynamic programming
  - Time and space complexity analysis

- Code Quality
  - Clean and readable code
  - Meaningful variable and function naming
  - Modular and reusable code
  - Object-oriented design principles
  - SOLID principles
  - Error handling and validation
  - Code documentation
  - Version control best practices
  - Refactoring techniques
  - Maintainability considerations

- Optimization
  - Algorithmic optimization
  - Reducing time complexity
  - Reducing space complexity
  - Efficient data structure selection
  - Avoiding unnecessary computations
  - Memory optimization
  - Handling large input sizes
  - Performance testing
  - Identifying bottlenecks
  - Trade-offs between readability and performance